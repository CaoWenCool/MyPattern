#单例模式
##定义
   单例模式是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点
    
   隐藏其所有的构造方法
    
   属于创建型模式
   
##适用场景
   确保任何情况下都绝对只有一个实例
   
   例如：ServletContext、ServletConfig、ApplicationContext、DBPool
   
##创建写法
   1、饿汉式单例
   2、懒汉式单例
   3、注册式单例
   4、ThreadLocal单例
   
###饿汉式单例
   饿汉式单例在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线程还没有出现以前就是实例化了，不可能存在
   访问安全问题
   优点：没有加任何锁、执行效率高，在用户体验上来说，比懒汉式更好。
   缺点：类加载的时候就初始化，不管用与不用都占着内存空间，浪费了内存
   
   Spring 中IOC容器ApplicationContext本身就是典型的饿汉式单例。饿汉式单例适用在单例对象比较少的情况。
   
###懒汉式单例
   懒汉式单例的特点是：被外部类调用的时候内部类才会加载。
   在lazySimpleSingleton中懒汉式单例中，如果不见synchronized会出现线程不安全的问题，如果加上synchronized的子啊大量线程时
   会导致性能下降，通过双重锁的方法可以提升其性能，但是synchronized 始终会影响线程的性能。所以，可以通过使用内部类的方
   式，内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题，例如：LazyInnerClassSingleton
   
###反射破坏单例
  针对以上地单例模式，如果只是加了private之外，没有做任何处理。我们可以使用反射来调用其构造方法，然后，在调用
  getInstance()方法，就会破坏单例地实例。例如：
  LazyInnerClassSingletonTest
  我们可以通过在构造方法中添加一些限制，一旦出现多次重复创建就抛出异常，来优化代码，防止反射地破坏。

### 序列化破坏单例
  当我们将一个单例对象创建好之后，有时候需要将对象序列化然后写入到磁盘，下次使用时再从磁盘中读取到对象，反序列化转化为
  内存对象。反序列化后地对象会重新分配内存，即重新创建。那如果序列化地目标对象为单例对象，就违背了单例模式地初衷，相当于
  破坏了单例。
  那么如何保证序列化地情况下也能够实现单例呢？只需要调用readResolve()方法。
  通过分析源码，我们可以看到实际上了实例化了两次，只不过新创建地对象没有被返回而已，如果，创建对象地动作发生频率增大，
  就意味着内存分配开销也会随之加大。
  
  
###注册式单例
   注册式单例又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一地标识来获取实例。注册式单例有两种写法：一种
   为容器缓存，一种为枚举登记。
   
###ThreadLocal单例
   ThreadLocal不能保证其创建的对象是全局唯一的，但是能保证在单个线程中是唯一的，天生的线程安全。
   
   那么ThreadLocal如何实现线程安全的效果呢？为了达到线程安全的目的，给方法上锁，以时间换空间。ThreadLocal将所有的对象
   全部放在ThreadLocalMap中，为每个线程都提供了一个对象，实际上是以空间换时间来实现线程间隔离的。
   
##优点
   在内存中只有一个实例，减少了内存开销
   可以避免对资源的多重占用
   设置全局访问点，严格控制访问。
   
##缺点
   没有接口，扩展困难
   如果要扩展单例对象，只有修改代码，没有其他途径
   
##总结
单例模式可以内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用
    