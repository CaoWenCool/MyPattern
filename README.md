一、Spring中常用的设计模式
1、分类
    （1） 创建型：工厂方法模式、抽象工厂模式、建造者模式、原型模式
    （2） 结构型：适配器模式、桥接模式、组合模式、装饰器模式、门面模式、享元模式、代理模式
    （3） 行为型：解释器模式、模板方法模式、责任链模式、命令模式、迭代器模式、调解者模式、备忘录模式、观察者模式、状态
    模式、策略模式、访问者模式
    
2、设置模式在应用中遵循的六大原则
    （1） 开闭原则：开闭原则就是对外扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热
    插拔的效果。所以一句话概括说就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类
    （2） 里氏替换原则：里氏替换原则面向对象设计的基本原则之一。里氏替换原则中说，任何基类可以出现的地方，子类一定可以
    出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不能受到影响时，基类才能真正被复用，而衍生类
    也能够在基类的基础上增加新的行为。里氏替换原则是对”开--闭“原则补充。实现里氏替换原则是对实现抽象化的具体步骤的
    规范。
    （3） 依赖倒转原则：这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
    （4） 接口隔离原则：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这我们看出，其实设计
    模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。
    （5） 迪米特法则:一个实体赢荡尽量少的与其他实体之间发生相互调用，使得系统功能模块相对独立。
    （6） 合成复用原则：原则是尽量使用合成/聚合的方式，而不是使用继承。
    设计模式之间的关系图如下：
3、Spring各种模式的介绍
   1.1 简单工厂模式
   应用场景：又叫做静态工厂方法模式，但是不属于23中设计模式之一。简单工厂模式的实质是由一个工厂类根据传入的参数，动态
   决定应该创建哪一个产品类。
   Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入
   参数前创建这个要根据具体情况而定
   
   归类：创建型模式
   特点：是复杂工厂模式的思维模型
   穷举：批量生产、标准化
   1.2 工厂方法模式
   应用场景:通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用想分离，采用工厂模式，即应用程序将对象的创建
   及初始化职责交给工厂对象。
   一般情况下，应用程序有自己的工厂对象来创建Bean，如果将应用程序自己的工厂对象交给Spring管理，那么Spring管理的就不是
   普通的Bean，而是工厂的Bean。
   
   归类：创建型模式
   特点：对于调用者来说，隐藏了负责的逻辑处理过程，调用者只关心执行结果。对于工厂来说要对结果负责，保证生产出符合规范的
   产品。
   穷举：流水线生产
   1.3 单例模式
   应用场景：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
   Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为Spring管理
   的是任意的Java对象。Spring下默认的Bean均为单例
  
   归类：创建型模式
   特点：保证从系统启动到系统终止，全过程只会产生一个实例。当我们在应用中遇到功能性冲突的时候，需要使用单例模式。
   穷举：配置文件、日历、IOC容器
   常用的单例模式写法：饿汉式、懒汉式、注册式、序列化
   1.4 原型模式
   应用场景：原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。所谓原型模式，就是java中的
   克隆技术，以某个对象为原型。复制出新的对象。显然新的对象具备原型对象的特点，效率高（避免了重复执行构造过程步骤）
   
   归类：创建型模式
   特点：首先有一个原型。数据内容相同，但对象实例不同（完全两个个体）
   穷举：孙悟空吹毫毛
   1.5 代理模式
   应用场景：为其他对象提供一种代理以控制对这个对象的访问。从结构上来看和Decorator模式类似，但是Proxy代理模式式控制，更
   像是一种对功能的限制，而Decorator是增加职责。
   Spring的Proxy模式再AOP中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy
   
   归类：结构型模式
   特点：执行者、被代理人、对于被代理人来说，这件事是一定要做的，但是我自己又不想或者没有时间做。对于代理人而言，需要获
   取到被代理人的个人资料，只是参与整个过程的某个或者几个环节。
   穷举：租房中介、售票黄牛、婚介、经纪人、快递、事务代理、非侵入式日志监听。
   1.6 策略模式
   应用场景：定义一系列的算法，把它们一个个封装起来，并且使他们可相互替换。本模式使得算法可独立于使用他的客户变化。
   Spring中再实例化对象的时候用到Strategy模式，再SimpleInstantiationStrategy有使用。
   
   归类:行为型模式
   特点：最终执行结果是固定的。执行过程和执行逻辑不一样。
   穷举：旅游出行方式
   1.7 模板方法模式
   定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重新定义该
   算法的某些特定步骤。
   Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。Spring中的JdbcTemplate，再用这个类
   时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎
   么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西时一段代码，而且这段代码会用到
   JdbcTemplate中的变量。怎么办？那我们就用回调对象，再这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这
   个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这就是Template Method
   不需要继承的另一种实现方式
   
   归类：行为型模式
   特点：执行流程固定，但中间有些步骤有细微的差别（运行时才确定）可实现批量生产/
   穷举：Spring ORM数据模型
   1.8 委派模式
   应用场景：不输于23种设计模式之一，是面向对象设计模式中常用的一个模式。这种模式的原理为类B和类A是两个互相没有关系的类，
   B具有和A一样的方法和属性：并且B调用A中的方法，属性就是调用A中同名的方法和属性。B好像就是一个受A授权委托的中介。第三方
   的代码不需要知道A的存在，也不需要和A发生直接的联系，通过B就可以直接使用A的功能，这样既能够使用到A的各种功能，又能够
   很好的将A保护起来了，一举两得。
   
   归类：行为型模式
   特点：要和代理人模式区分开来，持有被委托人的引用，不关心过程，只关心结果。
   穷举：经理派发工作任务Dispatcher
   1.9 适配器模式
   Spring AOP模式对BeforeAdvice AfterAdvice ThrowsAdvice三种通知类型的支持实际上是借助适配器模式来实现的，这样的好处是
   使得框架允许用户向框架中加入自己想要支持的任何一种通知类型，上述三种通知类型是Spring AOP模块定义的，它们是AOP联盟定
   义的，他们是AOP联盟定义的Advice的子类型。
   
   归类：结构型模式
   特点：注重兼容、转换。适配者与被适配者这之间没有层级关系，也没有必然联系。满足has - a的关系。
   穷举：编码解码、一拖三充电头、HDMI转VGA，Type-C转USB
   1.10 装饰器模式
   应用场景：在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户再每次访问中根据需要去访问不同
   的数据库。我们以往再Spring和Hibernate框架中总是配置一个数据源因而SessionFactory的DataSource属性总是指向这个数据源并且
   恒定不变，所有DAO在使用SessionFactory的时候都是通过这个数据源访问数据库。但是现在，由于项目需要，我们的DAO在访问
   SessionFactory的时候都不得不在多个数据源中不端切换，问题就出现了：如何让SessionFactory在执行数据库持久化的时候，根据
   客户的需求能够动态切换不同的数据源？我们能不能在Spring的框架下通过少量修改得到解决？是否以什么设计模式可以利用？
   首先想到在Spring的ApplicationContext中配置所有的DataSource。这些Datasource可能是各种不同类型的，比如不同数据库：
   Oracle、MySQL、SQL Server等等。也可能是不同的数据源：比如Apache提供的org.apache.commons.dbcp.BasicDataSource、Spring
   提供的org.springframework.jndi.JndiObjectFactoryBean等，然后SessionFactory提供客户的每次请求，将DataSource属性设置成
   不同的数据源，以达到切换数据源的目的。
   Spring中用到的包装器模式在类名上有两种表现：一种是类名种含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地
   给一个对象添加一些额外地职责。
   
   归类：结构性模式
   特点：注重覆盖和扩展。装饰器和被装饰器都实现同一个接口，主要目的是为了扩展之后依旧保留OOP关系。满足is-a的关系。
   穷举：IO流包装、数据源包装、简历包装。
   1.11 观察者模式
   应用场景：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
   Spring中Observer模式常用的地方时Listener的实现，
   
   归类：行为型模式
   特点：一般由两个角色足长：发布者与订阅者（观察者）。观察者通常有一个回调，也可以没有。
   穷举：监听器、日志收集、短信通知、邮件通知
4、各设计模式对比即编程思想的总结
   Spring思想：AOP
   应用场景：Aspect Oriented Programming(面向切面编程)找出多个类中有一定规律的代码，开发时拆开，运行时合并。面向切面
   编程，即面向规则编程
   一句话归纳：解耦，专人做专事
   Spring思想：OOP
   应用场景：Object Oriented Programming （面向对象编程）归纳总结生活中一切事物。
   一句话归纳：封装、继承、多态
   Spring编程思想：Bean Oriented Programming(面向Bean编程) 面向Bean（普通的JAVA类）设计程序
   一句话归纳：一切从Bean开始
   Spring编程思想：IOC
   应用场景：Inversion of Control(控制反转)将new对象的动作交割Spring管理，并由Spring保存已经创建的对象（IOC容器）
   一句话归纳：转交控制权（即控制权反转）
   DI/DL”Dependency Injection(依赖注入)或者Dependency Lookup(依赖查找)依赖注入、依赖查找，Spring不仅保存自己创建的对象
   ，而且保存对象与对象之间的关系。
   注入即赋值，主要三种凡是构造方法、set方法、直接赋值。
   一句话归纳：先理清关系再赋值。
   

   